Coin Pusher World – Autonomous Coding Spec
==========================================

Project name: Coin Pusher World  
Tech stack: Three.js + Vite + vanilla ES modules (JavaScript)  
Target platforms: Mobile-first (older Android phones), modern desktop browsers  

High-level goal
---------------

Evolve Coin Pusher World from a high-score arcade prototype into a **run-based roguelite coin-pusher game** that:

- Implements the board/coin/relic systems described in `docs/design-spec.md`
- Preserves and improves **performance on low-end Android devices**
- Keeps the current **Three.js + Vite + ES module** architecture
- Stays maintainable and well-tested over many long-running agent sessions

Authoritative design references
-------------------------------

When reasoning about requirements or making tradeoffs, treat these files as the single source of truth, in this order:

1. `docs/design-spec.md` – full game design and phased task list
2. `README.md` – current gameplay, platform constraints, and architecture overview
3. `plan.md` – refactoring plan for splitting the old monolithic files into `src/` modules

You should read these files early in each session and re-check them before making large architectural decisions.

Current state (summary)
-----------------------

- Existing game: a 3D vertical coin pusher with:
  - pyramid-style expansion of boards
  - power-up system, combo/jackpot systems, relic-like upgrades
  - custom physics and aggressive performance optimizations for old Android phones
- Codebase:
  - Legacy implementation in `js/*.js`
  - New ES module architecture under `src/`:
    - `src/core/` – `Game`, `Physics`, `Utils`
    - `src/world/` – `Board`, `Background`, `TextureGenerator`, `themes`
    - `src/systems/` – `Coins`, `PowerUps`, `Combo`, `Jackpot`, `CoinRain`, `Collectibles`, `Relics`
    - `src/ui/UI.js`, `src/audio/Sound.js`, `src/main.js`
- Tests:
  - Multiple Node-based test scripts (`test-*.js` / `*.cjs`) exercise simulation and gameplay flows.

Roguelite direction (what you are building)
------------------------------------------

Use `docs/design-spec.md` as the detailed design. At a high level you are moving toward:

- Run-based structure: acts, node map, battles, events, shops, bosses
- Coin system: coins as "cards" with tags, costs, and effects when they fall or hit slots
- Board system: multiple board layouts with passives/actives and upgrade paths
- Relic system: persistent buffs within a run that amplify synergies
- Synergy-focused builds: heavy/combos/defense/economy archetypes that reward skillful play

Core constraints (must not break)
---------------------------------

1. **Mobile performance**
   - Must remain smooth on older Android phones using WebGL 1.0.
   - Avoid heavy additional dependencies beyond Three.js and Vite.
   - Keep draw calls, geometry complexity, and texture sizes modest.
   - Avoid unnecessary re-rendering or per-frame allocations.

2. **Stability and tests**
   - Never delete or casually rewrite test files (e.g., `test-*.js`, `*.cjs`).
   - Prefer extending existing tests as you add new behavior.
   - Run focused tests for the systems you change before and after modifications.

3. **Incremental evolution**
   - Do **not** rewrite the entire game in a new framework or language.
   - Prefer incremental refactors that keep the game playable at all times.
   - Respect the existing ES module structure under `src/`.
   - Treat `js/*.js` as legacy—only touch them when needed; prefer moving logic into `src/`.

4. **User-facing quality**
   - No obviously broken states: overlapping UI, unreadable text, severe jitter.
   - Avoid introducing new UX friction, especially on touch devices.
   - Maintain simple, clear input (tap/click) and visible feedback.

Coding and architecture guidelines
----------------------------------

- Use **vanilla ES modules** (no React/Vue/Angular or heavy UI frameworks).
- Keep modules focused:
  - Core game loop in `src/core/Game.js`
  - Physics in `src/core/Physics.js`
  - Board/geometry in `src/world/*`
  - Systems (coins, relics, powerups, etc.) in `src/systems/*`
- When refactoring large files (especially `src/world/Board.js`):
  - Follow the structure and goals in `plan.md`.
  - Extract cohesive subsystems into new modules under `src/world/` or `src/world/themes/`.
  - After each extraction, re-run relevant tests and basic manual checks.
- Maintain existing API surfaces where possible:
  - `Game.init`, `Board.init`, `Coins.init`, `UI.init`, etc.
  - Window globals used by tests (e.g., `window.Game`, `window.Board`).

How to use this spec when generating feature_list.json
------------------------------------------------------

When the initializer agent creates `feature_list.json`:

- Base feature coverage primarily on:
  - `docs/design-spec.md` (gameplay systems and content)
  - `README.md` (current core mechanics and performance constraints)
  - `plan.md` (architectural refactor steps still relevant)
- Include both:
  - **Gameplay features** (run structure, coin types, boards, relics, UI flows)
  - **Technical features** (refactors, performance safeguards, test coverage)
- Split features into clear categories (examples, not exhaustive):
  - `"core-gameplay"`, `"roguelite-structure"`, `"boards-and-physics"`,
    `"coins-and-relics"`, `"ui-ux"`, `"performance"`, `"tests-and-tooling"`.

You may choose a smaller number of features than 200 (e.g., 40–80 well-scoped tests)
if that produces a more realistic and tractable long-running project. The features
must still comprehensively cover the design in `docs/design-spec.md`.

Non-goals (do NOT attempt)
--------------------------

- Rewriting the entire project in a different language or framework.
- Introducing large new dependencies (game engines, physics engines, full UI libraries).
- Removing performance optimizations simply for code style reasons.
- Turning the game into a fundamentally different genre (keep it a coin-pusher roguelite).

If you are ever unsure, prefer:
- Consulting `docs/design-spec.md`, `README.md`, and `plan.md`.
- Keeping the game playable and performant.
- Leaving clear notes in `claude-progress.txt` for future sessions.

